/*
 * Copyright (c) 2023-2025 Burak Sezer
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.kronotop.volume.replication;

import com.apple.foundationdb.MutationType;
import com.apple.foundationdb.Transaction;
import com.apple.foundationdb.directory.DirectorySubspace;
import com.apple.foundationdb.tuple.Tuple;
import com.apple.foundationdb.tuple.Versionstamp;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.kronotop.cluster.sharding.ShardKind;
import com.kronotop.internal.JSONUtil;
import com.kronotop.volume.VolumeMetadata;
import com.kronotop.volume.segment.Segment;

import java.util.HashSet;
import java.util.Set;
import java.util.TreeMap;
import java.util.function.Consumer;

import static com.kronotop.volume.Subspaces.REPLICATION_SLOT_SUBSPACE;

/**
 * Class representing a replication slot used for database replication.
 * A replication slot is responsible for tracking the replication state and snapshots
 * of a standby server.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
public class ReplicationSlot {
    private final TreeMap<Long, Snapshot> snapshots = new TreeMap<>();
    private final Set<ReplicationStage> completedStages = new HashSet<>();
    private long latestSegmentId;
    private byte[] receivedVersionstampedKey;
    private ReplicationStage replicationStage;
    private boolean active;
    private boolean stale;

    /**
     * Constructs a unique binary key for a replication slot using the specified replication configuration.
     * The key is generated by combining the replication slot subspace identifier, shard kind, shard ID,
     * an incomplete versionstamp, and volume configuration metadata.
     *
     * @param config the replication configuration containing shard kind, shard ID, and volume configuration
     * @return a byte array representing the constructed replication slot key
     */
    private static byte[] slotKey(ReplicationConfig config) {
        Tuple tuple = Tuple.from(
                REPLICATION_SLOT_SUBSPACE,
                config.shardKind().name(),
                config.shardId(),
                Versionstamp.incomplete()
        );
        return config.volumeConfig().subspace().packWithVersionstamp(tuple);
    }

    /**
     * Constructs a unique binary key for a replication slot using the specified shard metadata
     * and a volume subspace. The key is composed of a replication slot subspace identifier,
     * the {@code ShardKind}, shard ID, slot versionstamp, and details from the volume subspace.
     *
     * @param shardKind      the kind of shard to which the replication slot belongs
     * @param shardId        the unique identifier for the shard
     * @param slotId         the versionstamp uniquely identifying the replication slot
     * @param volumeSubspace the directory subspace used to structure the replication slot data
     * @return a byte array representing the fully built replication slot key
     */
    private static byte[] slotKey(ShardKind shardKind, int shardId, Versionstamp slotId, DirectorySubspace volumeSubspace) {
        Tuple tuple = Tuple.from(
                REPLICATION_SLOT_SUBSPACE,
                shardKind.name(),
                shardId,
                slotId
        );
        return volumeSubspace.pack(tuple);
    }

    /**
     * Constructs a unique binary key for the replication slot based on the given replication configuration
     * and slot identifier. The key is composed of the shard kind, shard ID, slot versionstamp, and volume
     * subspace information.
     *
     * @param config the replication configuration containing shard kind, shard ID, and volume configuration
     * @param slotId the unique versionstamp identifier of the replication slot
     * @return a byte array representing the fully composed key specific to the replication slot
     */
    private static byte[] slotKey(ReplicationConfig config, Versionstamp slotId) {
        return slotKey(config.shardKind(), config.shardId(), slotId, config.volumeConfig().subspace());
    }

    /**
     * Creates a new snapshot for a segment within a replication slot by retrieving metadata such as the
     * segment's first and last entries and calculating the total number of entries. The snapshot is then
     * encapsulated as an instance of {@code Snapshot}.
     *
     * @param tr        the transaction context used for accessing the database
     * @param config    the replication configuration containing volume and shard metadata
     * @param segmentId the unique identifier of the segment for which the snapshot is being created
     * @return a {@code Snapshot} object representing the segment's metadata and entry range
     */
    private static Snapshot newSegmentSnapshot(Transaction tr, ReplicationConfig config, long segmentId) {
        String segmentName = Segment.generateName(segmentId);
        SegmentLogEntry firstEntry = new SegmentLogIterable(
                tr,
                config.volumeConfig().subspace(),
                segmentName,
                null,
                null, 1
        ).iterator().next();
        SegmentLogEntry lastEntry = new SegmentLogIterable(
                tr,
                config.volumeConfig().subspace(),
                segmentName,
                null,
                null,
                1, true
        ).iterator().next();

        SegmentLog segmentLog = new SegmentLog(segmentName, config.volumeConfig().subspace());
        int totalEntries = segmentLog.getCardinality(tr);
        return new Snapshot(
                segmentId,
                totalEntries,
                firstEntry.key().getBytes(),
                lastEntry.key().getBytes()
        );
    }

    /**
     * Creates a new replication slot and initializes its snapshots based on the volume metadata,
     * then serializes and stores it in the database.
     *
     * @param tr     the transaction context used for accessing the database
     * @param config the replication configuration containing volume and shard details
     */
    public static void newSlot(Transaction tr, ReplicationConfig config) {
        ReplicationSlot slot = new ReplicationSlot();

        VolumeMetadata volumeMetadata = VolumeMetadata.load(tr, config.volumeConfig().subspace());
        for (Long segmentId : volumeMetadata.getSegments()) {
            Snapshot snapshot = newSegmentSnapshot(tr, config, segmentId);
            slot.getSnapshots().put(segmentId, snapshot);
        }

        byte[] key = slotKey(config);
        tr.mutate(MutationType.SET_VERSIONSTAMPED_KEY, key, JSONUtil.writeValueAsBytes(slot));
    }

    /**
     * Loads a replication slot based on the specified transaction, replication configuration, and slot ID.
     *
     * @param tr     the transaction used to retrieve the replication slot from the database
     * @param config the replication configuration containing shard kind, shard ID, and volume configuration
     * @param slotId the identifier of the replication slot
     * @return the loaded replication slot as an instance of {@code ReplicationSlot}
     */
    public static ReplicationSlot load(Transaction tr, ReplicationConfig config, Versionstamp slotId) {
        return ReplicationSlot.load(tr, config.shardKind(), config.shardId(), slotId, config.volumeConfig().subspace());
    }

    /**
     * Loads a replication slot based on the specified transaction, shard kind, shard ID,
     * slot ID, and volume subspace. The loaded replication slot is deserialized from the
     * database's stored value.
     *
     * @param tr             the transaction used to retrieve the replication slot from the database
     * @param shardKind      the kind of shard for which the replication slot is associated
     * @param shardId        the identifier of the shard
     * @param slotId         the identifier of the replication slot
     * @param volumeSubspace the directory subspace used to structure the key in the database
     * @return the loaded replication slot as an instance of {@code ReplicationSlot}
     * @throws ReplicationSlotNotFoundException if no replication slot is found for the given parameters
     */
    public static ReplicationSlot load(Transaction tr, ShardKind shardKind, int shardId, Versionstamp slotId, DirectorySubspace volumeSubspace) {
        byte[] key = slotKey(shardKind, shardId, slotId, volumeSubspace);
        byte[] value = tr.get(key).join();
        if (value == null) {
            throw new ReplicationSlotNotFoundException();
        }
        return JSONUtil.readValue(value, ReplicationSlot.class);
    }

    /**
     * Computes and updates a replication slot based on the specified parameters. The method retrieves
     * the replication slot from the database using the shard kind, shard ID, slot versionstamp, and volume
     * subspace. If the replication slot does not exist, an exception is thrown. The replication slot is then
     * deserialized, passed to the remapping function for updates, and re-serialized into the database.
     *
     * @param tr                the transaction context used to interact with the database
     * @param shardKind         the kind of shard to which the replication slot belongs
     * @param shardId           the unique identifier of the shard
     * @param slotId            the unique versionstamp identifying the replication slot
     * @param volumeSubspace    the directory subspace used to structure the replication slot data
     * @param remappingFunction a consumer function to modify the replication slot
     * @return the updated {@code ReplicationSlot} instance
     * @throws ReplicationSlotNotFoundException if no replication slot is found for the provided parameters
     */
    public static ReplicationSlot compute(Transaction tr, ShardKind shardKind, int shardId, Versionstamp slotId, DirectorySubspace volumeSubspace, Consumer<ReplicationSlot> remappingFunction) {
        byte[] key = slotKey(shardKind, shardId, slotId, volumeSubspace);
        byte[] value = tr.get(key).join();
        if (value == null) {
            throw new ReplicationSlotNotFoundException();
        }
        ReplicationSlot replicationSlot = JSONUtil.readValue(value, ReplicationSlot.class);
        remappingFunction.accept(replicationSlot);
        tr.set(key, JSONUtil.writeValueAsBytes(replicationSlot));
        return replicationSlot;
    }

    /**
     * Computes and updates a replication slot based on the specified replication configuration and slot ID.
     * The method retrieves the replication slot from the database using the shard kind, shard ID, slot versionstamp,
     * and volume subspace derived from the configuration. If the replication slot does not exist,
     * an exception is thrown. The replication slot is then deserialized, passed to the remapping function for
     * updates, and re-serialized into the database.
     *
     * @param tr                the transaction context used to interact with the database
     * @param config            the replication configuration containing shard kind, shard ID, and volume configuration
     * @param slotId            the unique versionstamp identifying the replication slot
     * @param remappingFunction a consumer function to modify the replication slot
     * @return the updated {@code ReplicationSlot} instance
     * @throws ReplicationSlotNotFoundException if no replication slot is found for the provided parameters
     */
    public static ReplicationSlot compute(Transaction tr, ReplicationConfig config, Versionstamp slotId, Consumer<ReplicationSlot> remappingFunction) {
        return compute(tr, config.shardKind(), config.shardId(), slotId, config.volumeConfig().subspace(), remappingFunction);
    }

    public ReplicationStage getReplicationStage() {
        return replicationStage;
    }

    public void setReplicationStage(ReplicationStage replicationStage) {
        this.replicationStage = replicationStage;
    }

    public Set<ReplicationStage> getCompletedStages() {
        // Keep this for JSON encode/decode.
        return completedStages;
    }

    public TreeMap<Long, Snapshot> getSnapshots() {
        return snapshots;
    }

    public byte[] getReceivedVersionstampedKey() {
        return receivedVersionstampedKey;
    }

    public void setReceivedVersionstampedKey(byte[] receivedVersionstampedKey) {
        this.receivedVersionstampedKey = receivedVersionstampedKey;
    }

    public long getLatestSegmentId() {
        return latestSegmentId;
    }

    public void setLatestSegmentId(long latestSegmentId) {
        this.latestSegmentId = latestSegmentId;
    }

    public boolean isReplicationStageCompleted(ReplicationStage stage) {
        return completedStages.contains(stage);
    }

    public void completeReplicationStage(ReplicationStage stage) {
        completedStages.add(stage);
    }

    public boolean isActive() {
        return active;
    }

    public void setActive(boolean active) {
        if (isStale()) {
            throw new IllegalStateException("Cannot activate a stale replication slot");
        }
        this.active = active;
    }

    public void setStale() {
        if (isActive()) {
            throw new IllegalStateException("Cannot mark a slot as stale while it's active");
        }
        this.stale = true;
    }

    public boolean isStale() {
        return stale;
    }
}

